"""
Principe de base récupéré de Mohit - Penetration Testing, 
modifié et complété en fonction de mes besoins
"""

from tkinter import *
import socket
import struct
import binascii
from libs.scapy.all import *

#Avant de sniffer, il nous faut mettre notre carte réseau en mode promisc via "ifconfig eth0 promisc"

def filtrage(typeFiltre, vEntree, egalite):
    """
    Arg: typeFiltre, le paramètre à filtrer; vEntree, la valeur à filtrer; egalite, on filtre l'égalité/inégalité (0 ou 1)
	Action :Crée et renvoie la liste filtre qui est nécessaire au filtrage des données à affichées par la fonction struct_2_win.pcktShow()
    Return : filtre, liste qui définit le filtre à appliquer
	"""
    #On applique le filtre
    filtre = [None]*14
    ##Filtre: 0: srcMac 1: NsrcMac 2: dstMac 3: NdstMac 4: srcIp 5: NsrcIp 6: dstIp 7: NdstIp 8: sport 9: Nsport 10: dport 11: Ndport
    if typeFiltre.get() != 'Pas de filtre' and vEntree!='':
        if typeFiltre.get() == 'Any MAC':
            if egalite.get() == 1:
                filtre[0] = vEntree.get().replace(':','')
                filtre[2] = vEntree.get().replace(':','')
            else:
                filtre[1] = vEntree.get().replace(':','')
                filtre[3] = vEntree.get().replace(':','')
        if typeFiltre.get() == 'Src MAC':
            if egalite.get() == 1:
                filtre[0] = vEntree.get().replace(':','')
            else:
                filtre[1] = vEntree.get().replace(':','')
        if typeFiltre.get() == 'Dst MAC':
            if egalite.get() == 1:
                filtre[2] = vEntree.get().replace(':','')
            else:
                filtre[3] = vEntree.get().replace(':','')
        if typeFiltre.get() == 'Any IP':
            if egalite.get() == 1:
                filtre[4] = vEntree.get().replace(':','')
                filtre[6] = vEntree.get().replace(':','')
            else:
                filtre[5] = vEntree.get().replace(':','')
                filtre[7] = vEntree.get().replace(':','')
        if typeFiltre.get() == 'Src IP':
            if egalite.get() == 1:
                filtre[4] = vEntree.get()
            else:
                filtre[5] = vEntree.get()
        if typeFiltre.get() == 'Dst IP':
            if egalite.get() == 1:
                filtre[6] = vEntree.get()
            else:
                filtre[7] = vEntree.get()
        if typeFiltre.get() == 'Any Port':
            if egalite.get() == 1:
                filtre[8] = vEntree.get().replace(':','')
                filtre[10] = vEntree.get().replace(':','')
            else:
                filtre[9] = vEntree.get().replace(':','')
                filtre[11] = vEntree.get().replace(':','')
        if typeFiltre.get() == 'Src Port':
            if egalite.get() == 1:
                filtre[8] = vEntree.get()
            else:
                filtre[9] = vEntree.get()
        if typeFiltre.get() == 'Dst Port':
            if egalite.get() == 1:
                filtre[10] = vEntree.get()
            else:
                filtre[11] = vEntree.get()
        if typeFiltre.get() == 'Protocol':
            if egalite.get() == 1:
                filtre[12] = vEntree.get()
            else:
                filtre[13] = vEntree.get()
    return filtre

def pcktInfo(pkt):
    """
	Arg : pkt, le paquet en question
    Action : Récupère les infos intéressantes du packets et les retourne dans un dictionnaire
	Return : dictionnaire contenant les différentes infos du paquet
    """
    
    #Initialisation des variables d'info
    srcMac = '-' 
    dstMac = '-' 
    ttl = '-' 
    srcIP = '-' 
    dstIP = '-' 
    sport = '-' 
    dport = '-' 
    flag = '-' 
    prot = '-'
    
    ethhead = pkt[0][0:14] #On ne s'intéresse qu'aux 14 bytes de long de l'Ethernet, du premier éléent du tuple, car on ne veut recevoir les infos du gateway
    eth = struct.unpack("!6s6s2s",ethhead) #On convertit les 14 en byte en 6 6 et 2 byte de Network (cf '!')
    dstMac = binascii.hexlify(eth[0]).decode("utf-8")
    srcMac = binascii.hexlify(eth[1]).decode("utf-8")
    etherType = eth[2]
    
    if etherType==b'\x08\x00':
        ipheader = pkt[0][14:34] #On extrait les 20 bytes suivants correspondant à l'IP
        ipHdr = struct.unpack("!8sB1s2s4s4s",ipheader) # On unpack selon le format ip et les infos que l'on veut récupérer
        table = {num:name[8:] for name,num in vars(socket).items() if name.startswith('IPPROTO')} #On crée une table de conversion de l'id d'un protocole vers son nom
        prot_id = int.from_bytes(ipHdr[2], byteorder='big') #On récupère l'id du protocole depuis sa valeur hex en byte
        prot = table[prot_id] #Nom du protocole
        ttl = str(ipHdr[1])
        prot = str(prot)
        srcIp = socket.inet_ntoa(ipHdr[4])
        dstIp = socket.inet_ntoa(ipHdr[5])
		
        if prot=='TCP':
            tcpheader = pkt[0][34:54]
            tcpHdr = struct.unpack("!HH9ss6s",tcpheader) #On extrait 9 9 et 6 (le flag)
            sport = str(tcpHdr[0])
            dport = str(tcpHdr[1])   
            flag = binascii.hexlify(tcpHdr[3])
            flagStr = '' #Flag tcp
            if prot == 'TCP':
                flag = bin(int(flag))[2:]
                if flag[0]==1:
                    flagStr += 'URG '
                elif len(flag)>1 and flag[1] == '1':
                    flagStr += 'ACK '
                elif len(flag)>2 and flag[2] == '1':
                    flagStr += 'PSH '
                elif len(flag)>3 and flag[3] == '1':
                   flagStr += 'RST '
                elif len(flag)>4 and flag[4] == '1':
                    flagStr += 'SYN '
                elif len(flag)>5 and flag[5] == '1':
                    flagStr += 'FIN '
                flag = flagStr

                for i in range(len(pkt[0])):
                    if pkt[0][(50+i):(50+i+4)] == b'HTTP':
                        prot = 'HTTP OK'
                        break
                    elif pkt[0][(50+i):(50+i+3)] == b'GET':
                        prot = 'HTTP GET'
                        break
                    elif pkt[0][(50+i):(50+i+4)] == b'POST':
                        prot = 'HTTP POST'
                        break
            else:
                flag = ''
        elif prot == 'UDP':
            udpheader = pkt[0][34:42]
            udpHdr = struct.unpack("!HH2s2s",udpheader)
            sport = str(udpHdr[0])
            dport = str(udpHdr[1])
            ttl = '-'
            flag = '-'
    elif etherType==b'\x08\x06':
        arpHeader = pkt[0][14:42]
        arpHdr = struct.unpack('!2s2sss2s6s4s6s4s', arpHeader)
        prot = 'ARP'
        srcIp = socket.inet_ntoa(arpHdr[6])
        dstIp = socket.inet_ntoa(arpHdr[8])
        ttl = '-'
        sport = '-'
        dport = '-'
        flag = '-'
    else :
        prot = '?'
        srcIp = '?'
        dstIp = '?'
        ttl = '-'
        sport = '-'
        dport = '-'
        flag = '-'

    return {'dstMac' : dstMac, 'srcMac' : srcMac, 'ttl' : ttl, 'prot' : prot, 'srcIp' : srcIp, 'dstIp' : dstIp, 'sport' : sport, 'dport' : dport, 'flag' : flag}

def pcktShow(pkt, filtre=[None]*14):
    """
	Arg : pkt, le paquet concerné; fitlre, la liste définissant le filtre à appliquer
    Action : Renvoie String qui sert à l'affichage d'un packet tout en filtrant les packets voulus ou non
	Return : infoLst, liste des infos du paquet, après avoir passé le filtre
    """
##    string=""
    dic = pcktInfo(pkt)
    
    nbrCond = 0
    for i in filtre:
        if i:
            nbrCond +=1

#Restrictions
##Filtre: 0: srcMac 1: NsrcMac 2: dstMac 3: NdstMac 4: srcIp 5: NsrcIp 6: dstIp 7: NdstIp 8: sport 9: Nsport 10: dport 11: Ndport
    ok = None
    if nbrCond == 1:
        if filtre[0]:
            if filtre[0] == dic['srcMac']:
                ok = 1
        if filtre[1]:
            if filtre[1] != dic['srcMac']:
                ok = 1
        if filtre[2]:
            if filtre[2] == dic['dstMac']:
                ok = 1
        if filtre[3]:
            if filtre[3] != dic['dstMac']:
                ok = 1
        if filtre[4]:
            if filtre[4] == dic['srcIp']:
                ok = 1
        if filtre[5]:
            if filtre[5] != dic['srcIp']:
                ok = 1
        if filtre[6]:
            if filtre[6] == dic['dstIp']:
                ok = 1
        if filtre[7]:
            if filtre[7] != dic['dstIp']:
                ok = 1
        if filtre[8]:
            if filtre[8] == dic['sport']:
                ok = 1
        if filtre[9]:
            if filtre[9] != dic['sport']:
                ok = 1
        if filtre[10]:
            if filtre[10] == dic['dport']:
                ok = 1
        if filtre[11]:
            if filtre[11] != dic['dport']:
                ok = 1
        if filtre[12]:
            if filtre[12][:3] == dic['prot'][:3]:
                ok = 1
        if filtre[13]:
            if filtre[13][:3] != dic['prot'][:3]:
                ok = 1
        
    elif nbrCond == 2:
        ok = 0
        if filtre[0]:
            if filtre[0] == dic['srcMac']:
                ok = 2
        if filtre[1]:
            if filtre[1] != dic['srcMac']:
                ok += 1
        if filtre[2]:
            if filtre[2] == dic['dstMac']:
                ok = 2
        if filtre[3]:
            if filtre[3] != dic['dstMac']:
                ok += 1
        if filtre[4]:
            if filtre[4] == dic['srcIp']:
                ok = 2
        if filtre[5]:
            if filtre[5] != dic['srcIp']:
                ok += 1
        if filtre[6]:
            if filtre[6] == dic['dstIp']:
                ok = 2
        if filtre[7]:
            if filtre[7] != dic['dstIp']:
                ok += 1
        if filtre[8]:
            if filtre[8] == dic['sport']:
                ok = 2
        if filtre[9]:
            if filtre[9] != dic['sport']:
                ok += 1
        if filtre[10]:
            if filtre[10] == dic['dport']:
                ok = 2
        if filtre[11]:
            if filtre[11] != dic['dport']:
                ok += 1
        if filtre[12]:
            if filtre[12][:3] == dic['prot'][:3]:
                ok = 2
        if filtre[13]:
            if filtre[13][:3] != dic['prot'][:3]:
                ok += 1
        if ok==2:
            ok = 1
        else:
            ok = 0
    else:
        ok = 1

    if ok == 1: #Si le packet a passé le filtre
        infoLst = [0]
        for i in range(2, len(dic['dstMac'])+3, 3):
            dic['dstMac'] = dic['dstMac'][:i] + ':' + dic['dstMac'][i:]
            dic['srcMac'] = dic['srcMac'][:i] + ':' + dic['srcMac'][i:]
        for i in dic:
            if i != 'data':
                infoLst.append(dic[i])
        return infoLst
    else:
        return [0]

#Création de notre socket
#--- socket.PF_PACKET     : Propre à Linux
#--- socket.SOCK_RAW      : S'en fout du Network Layer et crée un raccourci pour envoyer et recevoir des packets directement dans l'application
#--- socket.ntohs(0x0003) : On utilise tous les protocoles etherType (pas que IPv4, mais aussi ARP, ...)

##Filtre: 0: srcMac 1: NsrcMac 2: dstMac 3: NdstMac 4: srcIp 5: NsrcIp 6: dstIp 7: NdstIp 8: sport 9: Nsport 10: dport 11: Ndport

def sniffer(iface='wlan0', filtre=[None]*14):
    """
	Arg : iface, l'interface; filtre, la liste définissant le filtre
    Action : Crée un socket RAW sur l'interface voulue qui reçoit le premier packet "aperçu" et renvoie l'affichage du packet filtré et le packet
			 sous forme de bytes hexadécimaux dans un tuple de 2 éléments
	Return : tuple du dict de pcktShow() et pkt[0], le paquet sous forme de bytes
    """
    s = socket.socket(socket.AF_PACKET, socket.SOCK_RAW, socket.htons(0x0003))
    s.bind((iface, 0))
    pkt = s.recvfrom(2048) #On écoute sur un buffer de 2048
    return pcktShow(pkt, filtre), pkt[0]

sniffer('eth0')
